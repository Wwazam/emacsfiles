#+STARTUP: overview
#+TITLE: Uncle Dave's Emacs
#+CREATOR: Dawid 'daedreth' Eckert
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;

* Theme
** A nice theme
#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
    :ensure t
    :config
    (load-theme 'zenburn t))
#+END_SRC

** Font
    #+BEGIN_SRC emacs-lisp
    (set-face-font 'default "-Bits-Bitstream vera Sans Mono-normal-normal-normal-*-16-*-*-*-m-0-iso10646-1")
    #+END_SRC

* Basic Interface Settings
    These are setting that do not depend on packages and are built-in enhancements to the UI.
** Looks
*** Remove lame startup screen
We use an actual replacement for it, keep reading or head directly to =dashboard=.
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC

*** Disable menus and scrollbars
If you like using any of those, change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

*** Disable bell
This is annoying, remove this line if you like being visually reminded of events.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

*** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp 
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

** Functionality
*** Disable backups and auto-saves
I don't use either, you might want to turn those from =nil= to =t= if you do.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files t)
(setq auto-save-default t)
#+END_SRC

*** Change yes-or-no questions into y-or-n questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Async
Lets us use asynchronous processes wherever possible, pretty useful.
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t
    :init (dired-async-mode 1))
#+END_SRC

* Evil Mode
** Basic setup
#+BEGIN_SRC emacs-lisp
  (setq evil-search-module 'evil-search
          evil-want-C-u-scroll t
          evil-want-C-w-in-emacs-state t)

  (use-package evil
    :ensure t
    :bind ("C-." . nil)
    :config
      (use-package avy :ensure t)
      (define-key evil-insert-state-map (kbd "C-.") 'avy-goto-word-1)
      (define-key evil-normal-state-map (kbd "C-.") 'avy-goto-word-1)
      (define-key evil-visual-state-map (kbd "C-.") 'avy-goto-word-1)
      (define-key evil-motion-state-map (kbd "C-.") 'avy-goto-word-1)
      (bind-key "C-." 'avy-goto-word-1)
      (evil-mode 1))

#+END_SRC

** jk to go  Back to normal mode
#+BEGIN_SRC emacs-lisp
(use-package key-chord
    :ensure t)
(setq key-chord-two-keys-delay 1)
(key-chord-mode 1)

(key-chord-define evil-insert-state-map "kj" 'evil-normal-state)
(key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
(key-chord-define evil-replace-state-map "kj" 'evil-normal-state)
(key-chord-define evil-replace-state-map "jk" 'evil-normal-state)
#+END_SRC

** Remove C-. keybinding
#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-." ) nil)
  (global-unset-key (kbd "C-."))
#+END_SRC

** Keybindings
*** remove highlights
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x /") 'evil-ex-nohighlight)
#+END_SRC

** Evil Numbers
#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
    :ensure t)
(global-set-key (kbd "C-+") 'evil-numbers/inc-at-pt)
(global-set-key (kbd "C--") 'evil-numbers/dec-at-pt)
#+END_SRC

** Marks
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-local-map (kbd "'") 'evil-goto-mark)
#+END_SRC
* Eyebrowse
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
      :ensure t
      :init 
          (setq eyebrowse-keymap-prefix "\C-l")
      :config
          (setq eyebrowse-wrap-around t)
          (eyebrowse-setup-evil-keys)
          (eyebrowse-mode)
          )
#+END_SRC

* Window Manager
Everything regarding the WM or DE-like functionality is bundled here, remove the entire section if you do not wish to use =exwm=.
** exwm
The only time I actually had to use comments, this is for ease of removal if you happen to not like exwm.
*** Installation
#+BEGIN_SRC emacs-lisp
;  (use-package exwm
;    :ensure t
;    :config
;
;      ;; necessary to configure exwm manually
;      (require 'exwm-config)
;
;      ;; fringe size, most people prefer 1 
;      (fringe-mode 3)
;      
;      ;; emacs as a daemon, use "emacsclient <filename>" to seamlessly edit files from the terminal directly in the exwm instance
;      (server-start)
;
;      ;; this fixes issues with ido mode, if you use helm, get rid of it
;      (exwm-config-ido)
;
;      ;; a number between 1 and 9, exwm creates workspaces dynamically so I like starting out with 1
;      (setq exwm-workspace-number 1)
;
;      ;; this is a way to declare truly global/always working keybindings
;      ;; this is a nifty way to go back from char mode to line mode without using the mouse
;      (exwm-input-set-key (kbd "s-r") #'exwm-reset)
;      (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
;      (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)
;
;      ;; the next loop will bind s-<number> to switch to the corresponding workspace
;      (dotimes (i 10)
;        (exwm-input-set-key (kbd (format "s-%d" i))
;                            `(lambda ()
;                               (interactive)
;                               (exwm-workspace-switch-create ,i))))
;
;      ;; the simplest launcher, I keep it in only if dmenu eventually stopped working or something
;      (exwm-input-set-key (kbd "s-&")
;                          (lambda (command)
;                            (interactive (list (read-shell-command "$ ")))
;                            (start-process-shell-command command nil command)))
;
;      ;; an easy way to make keybindings work *only* in line mode
;      (push ?\C-q exwm-input-prefix-keys)
;      (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)
;
;      ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
;      (exwm-input-set-simulation-keys
;       '(
;         ;; movement
;         ([?\C-b] . left)
;         ([?\M-b] . C-left)
;         ([?\C-f] . right)
;         ([?\M-f] . C-right)
;         ([?\C-p] . up)
;         ([?\C-n] . down)
;         ([?\C-a] . home)
;         ([?\C-e] . end)
;         ([?\M-v] . prior)
;         ([?\C-v] . next)
;         ([?\C-d] . delete)
;         ([?\C-k] . (S-end delete))
;         ;; cut/paste
;         ([?\C-w] . ?\C-x)
;         ([?\M-w] . ?\C-c)
;         ([?\C-y] . ?\C-v)
;         ;; search
;         ([?\C-s] . ?\C-f)))
;
;      ;; this little bit will make sure that XF86 keys work in exwm buffers as well
;      (dolist (k '(XF86AudioLowerVolume
;                 XF86AudioRaiseVolume
;                 XF86PowerOff
;                 XF86AudioMute
;                 XF86AudioPlay
;                 XF86AudioStop
;                 XF86AudioPrev
;                 XF86AudioNext
;                 XF86ScreenSaver
;                 XF68Back
;                 XF86Forward
;                 Scroll_Lock
;                 print))
;      (cl-pushnew k exwm-input-prefix-keys))
;      
;      ;; this just enables exwm, it started automatically once everything is ready
;      (exwm-enable))
#+END_SRC

** Launchers
Since I do not use a GUI launcher and do not have an external one like dmenu or rofi,
I figured the best way to launch my most used applications would be direct emacsy
keybindings.
*** dmenu for emacs
Who would've thought this was available, together with ido-vertical it's a nice large menu
with its own cache for most launched applications.
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind
      ("s-SPC" . 'dmenu))
#+END_SRC

*** Functions to start processes
I guess this goes without saying but you absolutely have to change the arguments
to suit the software that you are using. What good is a launcher for discord if you don't use it at all.
#+BEGIN_SRC emacs-lisp
;  (defun exwm-async-run (name)
;    (interactive)
;    (start-process name nil name))
;
;  (defun daedreth/launch-discord ()
;    (interactive)
;    (exwm-async-run "discord"))
;
;  (defun daedreth/launch-browser ()
;    (interactive)
;    (exwm-async-run "qutebrowser"))
;
;  (defun daedreth/lock-screen ()
;    (interactive)
;    (exwm-async-run "slock"))
;
;  (defun daedreth/shutdown ()
;    (interactive)
;    (start-process "halt" nil "sudo" "halt"))
#+END_SRC

*** Keybindings to start processes
These can be modified as well, suit yourself.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-d") 'daedreth/launch-discord)
  (global-set-key (kbd "<s-tab>") 'daedreth/launch-browser)
  (global-set-key (kbd "<XF86ScreenSaver>") 'daedreth/lock-screen)
  (global-set-key (kbd "<XF86PowerOff>") 'daedreth/shutdown)
#+END_SRC

** Audio controls
This is a set of bindings to my XF86 keys that invokes pulsemixer with the correct parameters
*** Volume modifier
It goes without saying that you are free to modify the modifier as you see fit, 4 is good enough for me though.
#+BEGIN_SRC emacs-lisp
; (defconst volumeModifier "4")
#+END_SRC

*** Functions to start processes
#+BEGIN_SRC emacs-lisp
;  (defun audio/mute ()
;    (interactive)
;    (start-process "audio-mute" nil "pulsemixer" "--toggle-mute"))
;
;  (defun audio/raise-volume ()
;    (interactive)
;    (start-process "raise-volume" nil "pulsemixer" "--change-volume" (concat "+" volumeModifier)))
;
;  (defun audio/lower-volume ()
;    (interactive)
;    (start-process "lower-volume" nil "pulsemixer" "--change-volume" (concat "-" volumeModifier)))
#+END_SRC

*** Keybindings to start processes
You can also change those if you'd like, but I highly recommend keeping 'em the same, chances are, they will just work.
#+BEGIN_SRC emacs-lisp
; (global-set-key (kbd "<XF86AudioMute>") 'audio/mute)
; (global-set-key (kbd "<XF86AudioRaiseVolume>") 'audio/raise-volume)
; (global-set-key (kbd "<XF86AudioLowerVolume>") 'audio/lower-volume)
#+END_SRC

** Screenshots
I don't need scrot to take screenshots, or shutter or whatever tools you might have. This is enough.
These won't work in the terminal version or the virtual console, obvious reasons.

*** Screenshotting the entire screen
#+BEGIN_SRC emacs-lisp
;  (defun daedreth/take-screenshot ()
;    "Takes a fullscreen screenshot of the current workspace"
;    (interactive)
;    (when window-system
;    (loop for i downfrom 3 to 1 do
;          (progn
;            (message (concat (number-to-string i) "..."))
;            (sit-for 1)))
;    (message "Cheese!")
;    (sit-for 1)
;    (start-process "screenshot" nil "import" "-window" "root" 
;               (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
;    (message "Screenshot taken!")))
;  (global-set-key (kbd "<print>") 'daedreth/take-screenshot)
#+END_SRC

*** Screenshotting a region
#+BEGIN_SRC emacs-lisp
;  (defun daedreth/take-screenshot-region ()
;    "Takes a screenshot of a region selected by the user."
;    (interactive)
;    (when window-system
;    (call-process "import" nil nil nil ".newScreen.png")
;    (call-process "convert" nil nil nil ".newScreen.png" "-shave" "1x1"
;                  (concat (getenv "HOME") "/" (subseq (number-to-string (float-time)) 0 10) ".png"))
;    (call-process "rm" nil nil nil ".newScreen.png")))
;  (global-set-key (kbd "<Scroll_Lock>") 'daedreth/take-screenshot-region)
#+END_SRC

** Default browser
I use qutebrowser, so that's what I'll set up.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "firefox")
#+END_SRC

* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.
** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
      (projectile-mode 1))
#+END_SRC

** Let projectile call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Dashboard
This is your new startup screen, together with projectile it works in unison and
provides you with a quick look into your latest projects and files.
Change the welcome message to whatever string you want and
change the numbers to suit your liking, I find 5 to be enough.
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
      (dashboard-setup-startup-hook)
      (setq dashboard-startup-banner "~/.emacs.d/img/dashLogo.png")
      (setq dashboard-items '((recents  . 5)
                              (projects . 5)))
      (setq dashboard-banner-logo-title ""))
#+END_SRC

* Modeline
** SML
#+BEGIN_SRC emacs-lisp
  (display-battery-mode 0)
  (use-package smart-mode-line
      :ensure t
      :init
          (display-battery-mode 0)
      :config
          (sml/setup)
          (setq sml/theme 'respectful
              sml/mode-width 'full
              sml/name-width '(0 . 20)
              sml/replacer-regexp-list
              '(
                  ("^~/org/" ":O:")
                  ("^~/\\.emacs\\.d/" ":ED:")
                  ("^~/documents/notes/" ":N:")))
    )
#+END_SRC

** Hide Minor mode list
#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
      :ensure t
      :config
      (setq rm-blacklist
          (format "^ \\(%s\\)$"
              (mapconcat #'identity
                  '(".*" "Projectile.*" "PgLn")
                  "\\|")))
  )
#+END_SRC

* File manager
+I abandoned treemacs, looking for an alternative as we speak+
I found an alternative, Sunrise Commander!
I'm not changing much, just disabling the mouse and adding buttons.
#+BEGIN_SRC emacs-lisp
;  (use-package sunrise-commander
;    :ensure t
;    :init
;      (use-package sunrise-x-buttons :ensure t)
;      (use-package sunrise-x-modeline :ensure t)
;      (setq sr-cursor-follows-mouse nil)
;      (define-key sr-mode-map [mouse-1] nil)
;      (define-key sr-mode-map [mouse-movement] nil)
;    :bind ("s-t" . sunrise))
#+END_SRC

* Moving around emacs
One of the most important things about a text editor is how efficient you manage
to be when using it, how much time do basic tasks take you and so on and so forth.
One of those tasks is moving around files and buffers, whatever you may use emacs for
you /will/ be jumping around buffers like it's serious business, the following
set of enhancements aims to make it easier.

As a great emacs user once said:

#+BEGIN_QUOTE
Do me the favor, do me the biggest favor, matter of fact do yourself the biggest favor and integrate those into your workflow.
#+END_QUOTE
** a prerequisite for others packages
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t)
#+END_SRC

** scrolling and why does the screen move
I don't know to be honest, but this little bit of code makes scrolling with emacs a lot nicer.
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** which-key and why I love emacs
In order to use emacs, you don't need to know how to use emacs.
It's self documenting, and coupled with this insanely useful package, it's even easier.
In short, after you start the input of a command and stop, pondering what key must follow,
it will automatically open a non-intrusive buffer at the bottom of the screen offering
you suggestions for completing the command, that's it, nothing else.

It's beautiful
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :config
      (which-key-mode))
#+END_SRC

** windows,panes and why I hate other-window
Some of us have large displays, others have tiny netbook screens, but regardless of your hardware
you probably use more than 2 panes/windows at times, cycling through all of them with
=C-c o= is annoying to say the least, it's a lot of keystrokes and takes time, time you could spend doing something more productive.
*** switch-window
This magnificent package takes care of this issue.
It's unnoticeable if you have <3 panes open, but with 3 or more, upon pressing =C-x o=
you will notice how your buffers turn a solid color and each buffer is asigned a letter
(the list below shows the letters, you can modify them to suit your liking), upon pressing
a letter asigned to a window, your will be taken to said window, easy to remember, quick to use
and most importantly, it annihilates a big issue I had with emacs. An alternative is =ace-window=,
however by default it also changes the behaviour of =C-x o= even if only 2 windows are open,
this is bad, it also works less well with =exwm= for some reason.
#+BEGIN_SRC emacs-lisp
(use-package switch-window
  :ensure t
  :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
        '("a" "o" "e" "u" "h" "t" "n" "n" "s"))
  :bind
    ([remap other-window] . switch-window))
#+END_SRC

*** Following window splits
After you split a window, your focus remains in the previous one.
This annoyed me so much I wrote these two, they take care of it.
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
    (interactive)
    (split-window-right)
    (balance-windows)
    (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** swiper and why is the default search so lame
I like me some searching, the default search is very meh. In emacs, you mostly use search to get around your buffer, much like with avy, but sometimes it doesn't hurt to search for entire words or mode, swiper makes sure this is more efficient.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . 'swiper))
#+END_SRC

** buffers and why I hate list-buffers
Another big thing is, buffers. If you use emacs, you use buffers, everyone loves them.
Having many buffers is useful, but can be tedious to work with, let us see how we can improve it.
*** Always murder current buffer
Doing =C-x k= should kill the current buffer at all times, we have =ibuffer= for more sophisticated thing.
#+BEGIN_SRC emacs-lisp
  (defun kill-current-buffer ()
    "Kills the current buffer."
    (interactive)
    (kill-buffer (current-buffer)))
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
#+END_SRC

*** Kill buffers without asking for confirmation
Unless you have the muscle memory, I recommend omitting this bit, as you may lose progress for no reason when working.
#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions (delq 'process-kill-buffer-query-function kill-buffer-query-functions))
#+END_SRC

*** Turn switch-to-buffer into ibuffer
I don't understand how ibuffer isn't the default option by now.
It's vastly superior in terms of ergonomics and functionality, you can delete buffers, rename buffer, move buffers, organize buffers etc.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'helm-buffers-list)
#+END_SRC

*** close-all-buffers
It's one of those things where I genuinely have to wonder why there is no built in functionality for it.
Once in a blue moon I need to kill all buffers, and having ~150 of them open would mean I'd need to spend a few too many
seconds doing this than I'd like, here's a solution.

This can be invoked using =C-M-s-k=. This keybinding makes sure you don't hit it unless you really want to.
#+BEGIN_SRC emacs-lisp
  (defun close-all-buffers ()
    "Kill all buffers without regard for their origin."
    (interactive)
    (mapc 'kill-buffer (buffer-list)))
  (global-set-key (kbd "C-M-s-k") 'close-all-buffers)
#+END_SRC

** ido and why I started using helm
Sometimes, you don't realize how good something is until you try it extensively.
I give in, helm is awesome. I'll end up customizing it more eventually,
it's rather similar to ido-vertical though.
*** helm
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :bind
    ("C-x C-f" . 'helm-find-files)
    ("C-x C-b" . 'helm-buffers-list)
    ("M-x" . 'helm-M-x)
    :config
    (defun daedreth/helm-hide-minibuffer ()
      (when (with-helm-buffer helm-echo-input-in-header-line)
        (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
          (overlay-put ov 'window (selected-window))
          (overlay-put ov 'face
                       (let ((bg-color (face-background 'default nil)))
                         `(:background ,bg-color :foreground ,bg-color)))
          (setq-local cursor-type nil))))
    (add-hook 'helm-minibuffer-set-up-hook 'daedreth/helm-hide-minibuffer)
    (setq helm-autoresize-max-height 0
          helm-autoresize-min-height 40
          helm-M-x-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-recentf-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-split-window-in-side-p nil
          helm-move-to-line-cycle-in-source nil
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8 
          helm-echo-input-in-header-line t)
    :init
    (helm-mode 1))

  (require 'helm-config)    
  (helm-autoresize-mode 1)
  (define-key helm-find-files-map (kbd "C-w") 'helm-find-files-up-one-level)
  (define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
#+END_SRC

** avy and why it's the best thing in existence
Many times have I pondered how I can move around buffers even quicker.
I'm glad to say, that avy is precisely what I needed, and it's precisely what you need as well.
In short, as you invoke one of avy's functions, you will be prompted for a character
that you'd like to jump to in the /visible portion of the current buffer/.
Afterwards you will notice how all instances of said character have additional letter on top of them.
Pressing those letters, that are next to your desired character will move your cursor over there.
Admittedly, this sounds overly complicated and complex, but in reality takes a split second
and improves your life tremendously.

I like =M-s= for it, same as =C-s= is for moving by searching string, now =M-s= is moving by searching characters.
#+BEGIN_SRC emacs-lisp
  (use-package avy
      :ensure t
      :bind
          ("C-." . avy-goto-word-1))
#+END_SRC

** transpose frames
#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame
  :ensure t
  :bind
    ("C-x t" . 'transpose-frame))
#+END_SRC
* The terminal
I have used urxvt for years, and I miss it sometimes, but ansi-term is enough for most of my tasks.
** Default shell should be bash
I don't know why this is a thing, but asking me what shell to launch every single
time I open a terminal makes me want to slap babies, this gets rid of it.
This goes without saying but you can replace bash with your shell of choice.
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
#+END_SRC

** Easy to remember keybinding
In loving memory of bspwm, Super + Enter opens a new terminal, old habits die hard.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

* Text manipulation
Here I shall collect self-made functions that make editing text easier.
** Mark-Multiple
I can barely contain my joy. This extension allows you to quickly mark the next occurence of a region and edit them all at once. Wow!
#+BEGIN_SRC emacs-lisp
    (use-package mark-multiple
      :ensure t
      :config
          (define-key evil-visual-state-map (kbd "q") 'mark-next-like-this))

#+END_SRC

* Minor conveniences
Emacs is at it's best when it just does things for you, shows you the way, guides you so to speak.
This can be best achieved using a number of small extensions. While on their own they might not be particularly
impressive. Together they create a nice environment for you to work in.
** Visiting files
#+BEGIN_SRC emacs-lisp :results none
(define-key global-map (kbd "C-c f a")
  (defun my/Agenda () (interactive)(find-file "~/documents/notes/agenda.org")))
(define-key global-map (kbd "C-c f c")
  (defun my/Config () (interactive)(find-file "~/.emacs.d/config.org")))
(define-key global-map (kbd "C-c f e")
  (defun my/Elfeed () (interactive)(find-file "~/.emacs.d/elfeed.org")))
(define-key global-map (kbd "C-c f f")
  (defun my/Files () (interactive)(find-file "~/documents/notes/files.org")))
(define-key global-map (kbd "C-c f h")
  (defun my/Horraires () (interactive)(find-file "~/documents/notes/horraires.org")))
(define-key global-map (kbd "C-c f i")
  (defun my/Init () (interactive)(find-file "~/.emacs.d/init.el")))
(define-key global-map (kbd "C-c f j")
  (defun my/Diary () (interactive)(find-file "~/documents/notes/diary.org")))
(define-key global-map (kbd "C-c f p")
  (defun my/Project () (interactive)(find-file "~/documents/notes/project.org")))
(define-key global-map (kbd "C-c f s")
  (defun my/Scratch () (interactive)(switch-to-buffer "*scratch*")))
(define-key global-map (kbd "C-c f t")
  (defun my/Todo () (interactive)(find-file "~/documents/notes/todo.org")))
#+END_SRC


** Reloading the configuration
   
Simply pressing =Control-c r= will reload this file, very handy.
You can also manually invoke =config-reload=.
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

** Subwords
Emacs treats camelCase strings as a single word by default, this changes said behaviour.
<>
#+BEGIN_SRC emacs-lisp
  (global-subword-mode 0)
#+END_SRC

** Electric
If you write any code, you may enjoy this.
Typing the first character in a set of 2, completes the second one after your cursor.
Opening a bracket? It's closed for you already. Quoting something? It's closed for you already.

You can easily add and remove pairs yourself, have a look.
#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")
                           ))
#+END_SRC

And now to enable it
#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

** Beacon
While changing buffers or workspaces, the first thing you do is look for your cursor.
Unless you know its position, you can not move it efficiently. Every time you change
buffers, the current position of your cursor will be briefly highlighted now.
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
      (beacon-mode 1))
#+END_SRC

** Rainbow
Mostly useful if you are into web development or game
development. Every time emacs encounters a hexadecimal code that
resembles a color, it will automatically highlight it in the
appropriate color. This is a lot cooler than you may think.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
      (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Show parens
I forgot about that initially, it highlights matching parens when the cursor is just behind one of them.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC
** Rainbow delimiters
Colors parentheses and other delimiters depending on their depth, useful for any language using them,
especially lisp.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :init
      (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

** Expand region
A pretty simple package, takes your cursor and semantically expands the region, so words, sentences, maybe the contents of some parentheses, it's awesome, try it out.
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC

** Hungry deletion
On the list of things I like doing, deleting big whitespaces is pretty close to the bottom.
Backspace or Delete will get rid of all whitespace until the next non-whitespace character is encountered.
You may not like it, thus disable it if you must, but it's pretty decent.
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
      (global-hungry-delete-mode))
#+END_SRC

** Completion Ignore case
#+BEGIN_SRC emacs-lisp
  (setq completion-ignore-case t)
#+END_SRC

** Date names

#+BEGIN_SRC emacs-lisp
(setq calendar-week-start-day 1
          calendar-day-name-array ["Sunday" "Monday" "Tuesday" "Wednesday" 
                                   "Thursday" "Friday" "Saturday"]
          calendar-month-name-array ["Jannuary" "February" "Mars" "April" "May"
                                     "June" "July" "August" "September" 
                                     "October" "November" "December"])
#+END_SRC

#+RESULTS:
: ["Jannuary" "February" "Mars" "April" "May" "June" "July" "August" "September" "October" "November" "December"]

* Kill ring
There is a lot of customization to the kill ring, and while I have not used it much before,
I decided that it was time to change that.
** Maximum entries on the ring
The default is 60, I personally need more sometimes.
#+BEGIN_SRC emacs-lisp
  (setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
Out of all the packages I tried out, this one, being the simplest, appealed to me most.
With a simple M-y you can now browse your kill-ring like browsing autocompletion items.
C-n and C-p totally work for this.
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

* Programming
Minor, non-completion related settings and plugins for writing code.
** yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet-snippets :ensure t)
  (use-package yasnippet
    :diminish yas-minor-mode
    :ensure t
    :config
      (setq yas-indent-line 'fixed)
      (yas-global-mode 1)
      (yas-reload-all))
  (define-key yas-minor-mode-map (kbd "<C-SPC>") 'yas-expand)
#+END_SRC

** auto-yasnippet
#+BEGIN_SRC emacs-lisp
  (use-package auto-yasnippet
    :ensure t
    :bind (("C-c ya" . aya-create)
           ("C-c ye" . aya-expand)))
#+END_SRC
** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :defer 2
    :diminish
    :custom
    (flycheck-display-errors-delay .3)
    (flycheck-stylelintrc "~/.stylelintrc.json")
	)

#+END_SRC

** company mode
I set the delay for company mode to kick in to half a second, I also make sure that
it starts doing its magic after typing in only 2 characters.

I prefer =C-n= and =C-p= to move around the items, so I remap those accordingly.
#+BEGIN_SRC emacs-lisp
  (use-package company
      :ensure t
      :diminish company-mode
      :config
      (setq company-idle-delay 0)
      (setq company-minimum-prefix-length 3)
      :bind (:map company-active-map
          ("M-n" . nil)
          ("M-p" . nil)
          ("C-n" . company-select-next)
          ("C-p" . company-select-previous)
          ("SPC" . company-abort)))

  (use-package company-quickhelp
    :ensure t
    :config
    (company-quickhelp-mode 1)
    (setq company-quickhelp-delay nil))
#+END_SRC

** specific languages
Be it for code or prose, completion is a must.
After messing around with =auto-completion= for a while I decided to drop it
in favor of =company=, and it turns out to have been a great decision.

Each category also has additional settings.
*** c/c++
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
       (flycheck-clang-analyzer-setup)))
#+END_SRC

**** company
Requires libclang to be installed.
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
      (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
      :ensure t
      :init
          (autoload 'jedi:setup "jedi" nil t)
          (add-hook 'python-mode-hook 'jedi:setup)
      :config
          (require 'company)
          (add-to-list 'company-backends 'company-jedi))
          (add-hook 'python-mode-hook 'jedi:setup)
          (setq jedi:complete-on-dot t)   

  (defun python-mode-company-init ()
  (setq-local company-backends '((company-jedi
                                  company-etags
                                  company-dabbrev-code))))
#+END_SRC
**** hs-minor mode
folding mode 
#+BEGIN_SRC emacs-lisp
    (add-hook 'python-mode-hook 'hs-minor-mode)
#+END_SRC
*** emacs-lisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "/usr/bin/sbcl")
    (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC

*** lua
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'flycheck-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'lua-mode-hook 'company-mode)

  (defun custom-lua-repl-bindings ()
    (local-set-key (kbd "C-c C-s") 'lua-show-process-buffer)
    (local-set-key (kbd "C-c C-h") 'lua-hide-process-buffer))

  (defun lua-mode-company-init ()
    (setq-local company-backends '((company-lua
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-lua
    :ensure t
    :config
      (require 'company)
      (setq lua-indent-level 4)
      (setq lua-indent-string-contents t)
      (add-hook 'lua-mode-hook 'custom-lua-repl-bindings)
      (add-hook 'lua-mode-hook 'lua-mode-company-init))
#+END_SRC
*** bash
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'flycheck-mode)

#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-mode-hook 'company-mode)

  (defun shell-mode-company-init ()
    (setq-local company-backends '((company-shell
                                    company-shell-env
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-shell
    :ensure t
    :config
      (require 'company)
      (add-hook 'shell-mode-hook 'shell-mode-company-init))
#+END_SRC

* Git integration
Countless are the times where I opened ansi-term to use =git= on something.
These times are also something that I'd prefer stay in the past, since =magit= is
great. It's easy and intuitive to use, shows its options at a keypress and much more.
** magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("C-x g" . magit-status))
#+END_SRC
** git gutter
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
      :ensure t
      :config
          (global-git-gutter-mode +1)
  )
#+END_SRC
* Remote editing
** Editing with sudo
Pretty self-explanatory, useful as hell if you use exwm.
#+BEGIN_SRC emacs-lisp
  (use-package sudo-edit
    :ensure t
    :bind
      ("s-e" . sudo-edit))
#+END_SRC
* Org
One of the absolute greatest features of emacs is called
"org-mode". This very file has been written in org-mode, a lot of
other configurations are written in org-mode, same goes for academic
papers, presentations, schedules, blogposts and guides. Org-mode is
one of the most complex things ever, lets make it a bit more usable
with some basic configuration.


Those are all rather self-explanatory.

** Common settings

#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t)
  (setq org-confirm-babel-evaluate nil)
  (setq org-export-with-smart-quotes t)
  (setq org-src-window-setup 'current-window)
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Syntax highlighting for documents exported to HTML
#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
  ;(add-hook 'org-mode-hook
	    ;'(lambda ()
	       ;(visual-line-mode 1)))
#+END_SRC

** Keybindings
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c '") 'org-edit-src-code)
#+END_SRC

** Org Bullets
Makes it all look a bit nicer, I hate looking at asterisks.
#+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :ensure t)
  (setq org-bullets-fac-name (quote org-bullet-face))
  (add-hook 'org-mode-hook (lambda ()(org-bullets-mode 1)))

  (setq org-bullets-bullet-list '("·"))

  ;(setq org-ellipsis " ▼")
(set-display-table-slot standard-display-table 
                        'selective-display (string-to-vector " …")) ; or whatever you like
#+END_SRC

** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
** Exporting options
One of the best things about org is the ability to export your file to many formats.
Here is how we add more of them!

*** latex
#+BEGIN_SRC emacs-lisp
  (when (file-directory-p "/usr/share/emacs/site-lisp/tex-utils")
    (add-to-list 'load-path "/usr/share/emacs/site-lisp/tex-utils")
    (require 'xdvi-search))
#+END_SRC
*** Twitter Bootstrap
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+END_SRC
*** Plantum
#+BEGIN_SRC emacs-lisp
(setq org-plantuml-jar-path
      (expand-file-name "~/.emacs.d/src/plantuml.jar"))
#+END_SRC
** TO DO keywords
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords 
      '((sequence "NOW(n)" "TODO(t)" "CHECK(c@)" "LATER(l)" "WAIT(w@)" "|" "DONE(d!)" )
      (sequence "BUG(b@)" "ISSUE(i@)" "|" "FIXED(f!)")
      (sequence "|" "CANCELED(a@)")
  ))

  (setq org-todo-keyword-faces
      '(
          ("NOW" .(:foreground "#ac7373" :weight bold)) 
          ("TODO" .(:foreground "#bc8383" :weight bold)) 
          ("DONE" .(:foreground "#94bff3")) 
          ("LATER" .(:foreground "#ffc9a4")) 
          ("CHECK" .(:foreground "#f0dfaf")) 
          ("WAIT" .(:foreground "#ebe9bf")) 
          ("BUG" .(:foreground "#8c5353" :weight bold)) 
          ("ISSUE" .(:foreground "#dfaf8f")) 
          ("FIXED" .(:foreground "#9fc59f"))
          ("CANCELED" .(:foreground "#7f9f7f"))
  ))

  (setq org-log-into-drawer t)
#+END_SRC
** Closed timestamp
#+BEGIN_SRC emacs-lisp
;(setq org-log-done 'time)
#+END_SRC
** Capture
*** Installation
#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-cc" 'org-capture)
#+END_SRC

*** Default Files
#+BEGIN_SRC emacs-lisp
  (setq org-defaults-notes-file "~/documents/notes/notes.org")
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/documents/notes/todo.org" "Tasks")
               "* TODO %?\n  %i\n  %a")
          ("j" "Journal" entry (file+datetree "~/documents/notes/diary.org")
           "* %?\nEntered on %U\n  %i\n")
          ("f" "Files" entry (file+headline "~/documents/notes/files.org" "Files")
          "* %?\n[[file:%F][%F]]")
          ("a" "Agenda" entry (file+headline "~/documents/notes/agenda.org" "Evenements")
           "* %?\nEntered on %U\n  %i\n")
          ))
#+END_SRC

** Betterhandeling of 'O'
 An override for this function to make inserting headings work
 a bit better. Makes O respect heading content.

#+BEGIN_SRC emacs-lisp
(defun shellhead/smart-org-insert ()
  "Creates a new heading if currently in a heading, creates a new list item 
   if in a list, or creates a newline if neither."
  (interactive)
  (cond
   ((org-at-heading-p) (org-insert-heading-respect-content) (evil-insert-state))
   ((org-at-item-p) (org-insert-item))))
#+END_SRC

** Link
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c l") 'org-store-link)
#+END_SRC
** Scrivener mode
C-c h to open plan in left pane

#+BEGIN_SRC emacs-lisp
  (defun org-tree-open-in-right-frame ()
    (interactive)
    (org-tree-to-indirect-buffer)
  (windmove-right))

    (add-hook 'org-mode-hook 
              (lambda ()
                ;; TODO: set fringe/gutter mode and theme by mode, no fringe and white them for ORG files
                ;; fringe and black theme for code
                (fringe-mode 0)
                ;; (set-frame-parameter (window-frame) 'background-mode 'dark)
                ;; (enable-theme 'leuven)

                (define-key evil-normal-state-local-map [S-return] (quote org-tree-open-in-right-frame))
                (define-key evil-normal-state-local-map [return] (quote org-tree-to-indirect-buffer))
    ))

    (define-key global-map (kbd "C-c h")
      (lambda ()
        (interactive)
        (delete-other-windows)
        (split-window-right)
        (enlarge-window-horizontally -9999)
        (enlarge-window-horizontally 50)
      ))
#+END_SRC

** evil-org
#+BEGIN_SRC emacs-lisp
(use-package evil-org
    :ensure t) 
(add-hook 'org-mode-hook (lambda ()(evil-org-mode 1)))
#+END_SRC
** org-journal
#+BEGIN_SRC emacs-lisp
  (use-package org-journal
:ensure t)
#+END_SRC
** clocking
*** change indent symbol
org indent symbol in clock reports is bugged (some latex problem, idk, idc) and we get those nice "/emsp", so let's change that
#+BEGIN_SRC emacs-lisp
(defun my-org-clocktable-indent-string (level)
  (if (= level 1)
      ""
    (let ((str "."))
      (while (> level 2)
        (setq level (1- level)
              str (concat str "  ")))
      (concat str "  "))))

(advice-add 'org-clocktable-indent-string :override #'my-org-clocktable-indent-string)
#+END_SRC

#+RESULTS:
*** drawer
automatically add clock items in a drawer
#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer t)
#+END_SRC
** org-agenda
#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-c a") 'org-agenda)
    (setq org-agenda-custom-commands
          '(("h" "Daily habits" 
             ((agenda ""))
             ((org-agenda-show-log t)
              (org-agenda-ndays 7)
              (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp ":DAILY:"))))
            ;; other commands here
            ))
    (setq org-agenda-log-mode-items '(closed clock state))
#+END_SRC
** org-number
#+BEGIN_SRC emacs-lisp
(use-package evil-numbers
    :ensure t) 
(global-set-key (kbd "C-+") 'evil-numbers/inc-at-pt)
(global-set-key (kbd "C--") 'evil-numbers/dec-at-pt)
#+END_SRC
** org-babel
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
      'org-babel-load-languages
          '(
          (python . t)
          (sql . t)
          (emacs-lisp . t)
          (plantuml . t)))
#+END_SRC
* LaTeX
** Initialize
#+BEGIN_SRC emacs-lisp
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)

#+END_SRC
** Run all
#+BEGIN_SRC emacs-lisp
  ;; (define-key LaTeX-mode-map (kbd "C-c C-a")
  ;;   (lambda ()
  ;;     "Save the buffer and run `TeX-command-run-all`."
  ;;     (interactive)
  ;;     (save-buffer)
  ;;     (TeX-command-run-all nil)))
#+END_SRC

#+RESULTS:
: t

* Instant messaging 
I like IRC, I also like other protocols but I enjoy IRC most, it's obvious that I long
for a way to do my messaging from within emacs.
There is plenty of IRC clients in the repositories, and some more in the emacs repositories
but I find that the default =erc= does the job best, it's easy to use and offers some conveniences
that more sophisticated ones don't, so I use it.

** erc, also known as "a way to ask for help on #emacs"
You might want to edit the default nick, it's password protected anyway so don't bother.

* Tools
** Calculator
set key
& start it in emacs mode
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-=") 'calculator)
(add-to-list 'evil-emacs-state-modes 'calculator-mode)
#+END_SRC
** RSS
*** Installation
Elscreen for RSS feed
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
      :ensure t
      :bind
          ("C-x w" . 'elfeed)
          (:map elfeed-search-mode-map
          ("j" . next-line)
          ("k" . previous-line)
          ("v" . elfeed-search-mpv)
          :map elfeed-show-mode-map
          ("j" . scroll-up-line)
          ("k" . scroll-down-line))
      :config 
          (setq-default elfeed-search-filter "@3-days-ago +unread -youtube "))

  (use-package elfeed-org
      :ensure t
      :config
  (setq rmh-eleed-org-files (list "~/.emacs.d/elfeed.org")))
  (elfeed-org)

  (add-to-list 'evil-emacs-state-modes 'elfeed-search-mode)

  (defface youtube-elfeed-entry
    '((t :foreground "#e55"))
    "Marks an youtube Elfeed entry.")
  (push '(youtube youtube-elfeed-entry)
        elfeed-search-face-alist)
#+END_SRC
*** Read youtube
#+BEGIN_SRC emacs-lisp
(defun elfeed-play-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (quality-arg "")
        (quality-val (completing-read "Max height resolution (0 for unlimited): " '("0" "480" "720") nil nil)))
    (setq quality-val (string-to-number quality-val))
    (message "Opening %s with height≤%s with mpv..." (elfeed-entry-link entry) quality-val)
    (when (< 0 quality-val)
      (setq quality-arg (format "--ytdl-format=[height<=?%s]" quality-val)))
    (start-process "elfeed-mpv" nil "mpv" quality-arg (elfeed-entry-link entry))))

(defvar elfeed-mpv-patterns
  '("youtu\\.?be")
  "List of regexp to match against elfeed entry link to know
whether to use mpv to visit the link.")

(defun elfeed-visit-or-play-with-mpv ()
  "Play in mpv if entry link matches `elfeed-mpv-patterns', visit otherwise.
See `elfeed-play-with-mpv'."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (patterns elfeed-mpv-patterns))
    (while (and patterns (not (string-match (car elfeed-mpv-patterns) (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (if patterns
        (elfeed-play-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC
** Neotree
#+BEGIN_SRC emacs-lisp
  (use-package neotree
      :ensure t
      :bind ("C-x C-n" . 'neotree-toggle))
  (add-to-list 'evil-emacs-state-modes 'neotree-mode)
#+END_SRC
** Images
#+BEGIN_SRC emacs-lisp
(add-to-list 'evil-emacs-state-modes 'Image-mode)
#+END_SRC
** macros
*** keep recording even when changing buffers
https://github.com/emacs-evil/evil/issues/847
#+BEGIN_SRC emacs-lisp
(defun evil-abort-macro ())
#+END_SRC
* Misc keymapping
** M-x
This keybinding got removed for some reasons
#+BEGIN_SRC emacs-lisp
;(global-set-key (kbd "C-SPC") 'execute-extended-command)
#+END_SRC
** C-h h
AAAAAAAAH, begone, you useless and oh so cumbersome function!
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "C-h h"))
#+END_SRC
